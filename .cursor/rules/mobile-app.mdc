---
globs: app/mobile/**/*
description: モバイルアプリケーション開発のガイドライン
---

# モバイルアプリケーション開発ルール

## モバイルアプリ設計原則

- **クロスプラットフォーム**対応
- **ネイティブパフォーマンス**の追求
- **オフライン機能**の実装
- **ユーザビリティ**の最優先

## 技術スタック選択

- **React Native** (推奨)
  - JavaScript/TypeScriptの知識を活用
  - コードの共有化が可能
  - 豊富なエコシステム
- **Flutter** (代替案)
  - 高いパフォーマンス
  - 統一されたUI
  - Dart言語の習得が必要

## ディレクトリ構造

```plaintext
app/mobile/
├── src/
│   ├── components/    # 再利用可能なコンポーネント
│   │   ├── common/    # 共通コンポーネント
│   │   ├── forms/     # フォームコンポーネント
│   │   └── navigation/ # ナビゲーションコンポーネント
│   ├── screens/       # 画面コンポーネント
│   │   ├── auth/      # 認証画面
│   │   ├── study/     # 学習画面
│   │   └── profile/   # プロフィール画面
│   ├── navigation/    # ナビゲーション設定
│   ├── services/       # API・外部サービス
│   ├── hooks/          # カスタムHooks
│   ├── utils/          # ユーティリティ関数
│   └── types/          # 型定義
├── assets/            # 静的リソース
│   ├── images/        # 画像ファイル
│   ├── icons/         # アイコンファイル
│   └── fonts/         # フォントファイル
├── android/           # Android固有設定
├── ios/              # iOS固有設定
└── package.json      # 依存関係管理
```

## React Native 実装パターン

```typescript
// 画面コンポーネント
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { useStudySession } from '../hooks/useStudySession';

interface StudySessionScreenProps {
  navigation: NavigationProp<any>;
}

export const StudySessionScreen: React.FC<StudySessionScreenProps> = ({ navigation }) => {
  const { session, startSession, endSession } = useStudySession();

  return (
    <View style={styles.container}>
      <Text style={styles.title}>学習セッション</Text>
      {/* 実装 */}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
  },
});
```

## ナビゲーション設計

```typescript
// React Navigation設定
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';

const Stack = createStackNavigator();

export const AppNavigator = () => {
  return (
    <NavigationContainer>
      <Stack.Navigator initialRouteName="Home">
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="Study" component={StudyScreen} />
        <Stack.Screen name="Profile" component={ProfileScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
};
```

## 状態管理

```typescript
// Redux Toolkit使用例
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

interface StudyState {
  sessions: StudySession[];
  loading: boolean;
  error: string | null;
}

const initialState: StudyState = {
  sessions: [],
  loading: false,
  error: null,
};

export const fetchStudySessions = createAsyncThunk(
  'study/fetchSessions',
  async (userId: string) => {
    const response = await api.get(`/users/${userId}/study-sessions`);
    return response.data;
  }
);

const studySlice = createSlice({
  name: 'study',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchStudySessions.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchStudySessions.fulfilled, (state, action) => {
        state.loading = false;
        state.sessions = action.payload;
      });
  },
});
```

## オフライン機能

```typescript
// オフライン対応の実装
import NetInfo from '@react-native-community/netinfo';
import AsyncStorage from '@react-native-async-storage/async-storage';

export const useOfflineSync = () => {
  const [isOnline, setIsOnline] = useState(true);
  const [pendingActions, setPendingActions] = useState([]);

  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      setIsOnline(state.isConnected);

      if (state.isConnected && pendingActions.length > 0) {
        syncPendingActions();
      }
    });

    return unsubscribe;
  }, []);

  const syncPendingActions = async () => {
    // オフライン中のアクションを同期
  };
};
```

## パフォーマンス最適化

- **FlatList**の適切な使用
- **画像の最適化**（WebP形式の使用）
- **メモ化**の実装
- **バンドルサイズ**の最適化

## セキュリティ

- **証明書ピニング**の実装
- **機密情報**の適切な管理
- **バイオメトリック認証**の統合
- **データ暗号化**の実装

## テスト戦略

```typescript
// Jest + React Native Testing Library
import { render, fireEvent } from '@testing-library/react-native';
import { StudySessionScreen } from '../StudySessionScreen';

describe('StudySessionScreen', () => {
  it('should start study session when button is pressed', () => {
    const mockNavigation = { navigate: jest.fn() };
    const { getByText } = render(
      <StudySessionScreen navigation={mockNavigation} />
    );

    const startButton = getByText('学習開始');
    fireEvent.press(startButton);

    // アサーション
  });
});
```

## デプロイメント

- **Fastlane**による自動化
- **App Store Connect**への自動アップロード
- **Google Play Console**への自動アップロード
- **CodePush**によるホットアップデート

## 品質基準

- **TypeScript**の厳密な使用
- **ESLint**による静的解析
- **Prettier**によるコードフォーマット
- **単体テスト**の充実

## ユーザビリティ

- **アクセシビリティ**の対応
- **多言語対応**（i18n）
- **ダークモード**の実装
- **ジェスチャー操作**の最適化
